<?xml version="1.0" encoding="UTF-8"?>
<!-- Story Context for Story 2.5: Message Translation -->
<!-- Generated: 2025-11-02 (UPDATED v3.0) -->
<!-- Agent: John (Product Manager) -->
<!-- ARCHITECTURE: NestJS Backend REST Endpoint -->

<story-context id="story-2.5" epic="2" story="5" version="3.0">
  <metadata>
    <title>Message Translation</title>
    <status>Approved</status>
    <created>2025-11-01</created>
    <last-updated>2025-11-02</last-updated>
    <agent-model>claude-sonnet-4-5-20250929</agent-model>
    <architecture-version>3.0 - NestJS Backend REST Endpoint (BREAKING CHANGE)</architecture-version>
    <breaking-change>Changed from Next.js API routes to NestJS backend due to static export</breaking-change>
  </metadata>

  <summary>
Complete story context for implementing message translation using NestJS backend REST endpoint, @nestjs/throttler rate limiting, database caching, and Groq Llama 3.3 70B API. Frontend is static export on Cloudflare Pages, backend is NestJS on Render (free tier). Translations encrypted client-side before database storage for E2EE compliance.
  </summary>

  <architecture-decision>
**v3.0 BREAKING CHANGE:** Translation endpoint moved from Next.js API routes to NestJS backend REST controller.

**Reason:** Frontend uses `output: 'export'` (static export) for Cloudflare Pages deployment. Next.js API routes require Node.js server, not supported with static export.

**Solution:** Add POST /api/translate REST endpoint to existing NestJS backend on Render (free tier). Reuses existing JWT guards, PrismaService, and CORS configuration.

**Benefits:**
- No new infrastructure needed (still $0/month)
- Centralized backend logic in NestJS
- Professional N-tier architecture (Controllers → Services → Prisma)
- Shares business logic with GraphQL API
  </architecture-decision>

  <key-files>
**Backend Files to CREATE:**
- apps/backend/src/translation/translation.module.ts
- apps/backend/src/translation/translation.controller.ts (POST /api/translate)
- apps/backend/src/translation/translation.service.ts
- apps/backend/src/translation/groq.service.ts
- apps/backend/src/translation/dto/translate.dto.ts
- apps/backend/prisma/migrations/xxx_add_message_translations.sql

**Backend Files to MODIFY:**
- apps/backend/src/app.module.ts (add ThrottlerModule, TranslationModule)
- apps/backend/prisma/schema.prisma (add MessageTranslation model)
- apps/backend/src/schema.gql (add MessageTranslation type, mutations)
- apps/backend/.env (add GROQ_API_KEY, update CORS_ALLOWED_ORIGINS)
- apps/backend/package.json (add @nestjs/throttler)

**Frontend Files to CREATE:**
- src/components/chat/translation-display.tsx

**Frontend Files to MODIFY:**
- src/components/chat/message-bubble.tsx (integrate TranslationDisplay)
  </key-files>

  <critical-dependencies>
- **Story 5.4 (Language Settings):** BLOCKER - provides user.preferences.preferredLanguage
- **NestJS Backend:** Existing on Render (PrismaService, JWT guards, CORS)
- **Static Frontend:** Cloudflare Pages (no API routes support)
  </critical-dependencies>

  <technology-stack>
**Backend:**
- @nestjs/throttler v6.4.0 (rate limiting - NEW)
- @nestjs/common, @nestjs/core (existing)
- @prisma/client (existing)
- Groq API (Llama 3.3 70B Versatile)

**Frontend:**
- React 19, Next.js 15 (static export)
- @apollo/client (existing - for GraphQL mutations)
- AbortController (memory leak prevention)

**External Services:**
- Groq API: 30 RPM free tier, $0.59/million input tokens
- Render: Free tier NestJS backend
- Cloudflare Pages: Free tier static hosting
  </technology-stack>

  <rate-limiting>
**Implementation:** @nestjs/throttler with 2-tier strategy

| Tier | Limit | Window | Scope |
|------|-------|--------|-------|
| Short | 10 | 1 min | Per user (JWT sub) |
| Long | 100 | 1 day | Per user (JWT sub) |

**Behavior:**
- Cached translations bypass all rate limits (DB check first)
- HTTP 429 response with Retry-After header
- Token bucket algorithm (built-in)
- Applied at controller level with @Throttle decorator
  </rate-limiting>

  <database-schema>
```sql
CREATE TABLE message_translations (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  message_id UUID NOT NULL REFERENCES messages(id) ON DELETE CASCADE,
  target_language VARCHAR(5) NOT NULL,
  encrypted_translation TEXT NOT NULL, -- AES-256-GCM ciphertext
  created_at TIMESTAMPTZ DEFAULT NOW(),
  UNIQUE(message_id, target_language)
);
CREATE INDEX idx_message_translations_message_id ON message_translations(message_id);
```
  </database-schema>

  <implementation-flow>
1. Frontend: TranslationDisplay component renders with decrypted message
2. Frontend: Gets user.preferences.preferredLanguage from useAuth()
3. Frontend: Calls POST https://backend.onrender.com/api/translate (with JWT)
4. Backend: JwtAuthGuard authenticates request, extracts user info
5. Backend: TranslationService checks DB cache (message_id, target_language)
6. Backend: If cached, return encrypted translation immediately (bypass rate limit)
7. Backend: If not cached, apply @nestjs/throttler rate limit check
8. Backend: If rate limit OK, GroqService calls Groq API
9. Backend: Returns translation to frontend
10. Frontend: Encrypts translation with family key (E2EE)
11. Frontend: Caches encrypted translation via GraphQL mutation
12. Frontend: Displays translation below original (if different)
  </implementation-flow>

  <security-privacy>
**Privacy Model (Honest Disclosure):**
- **Tier 1 (Messages):** Pure E2EE - backend never sees plaintext
- **Tier 2 (Translations):** Backend + Groq temporarily see plaintext (necessary for translation)
- **At Rest:** Translations encrypted client-side before DB storage (E2EE)

**Security Guarantees:**
✅ Backend never stores plaintext translations
✅ Database breach exposes only ciphertext
✅ API key server-side only (GROQ_API_KEY, NOT NEXT_PUBLIC)
✅ JWT authentication required
✅ Rate limiting prevents abuse
⚠️ Backend + Groq temporarily see plaintext during translation

**Acceptable Tradeoff:** Translation requires plaintext access. Users can disable translation for full E2EE.
  </security-privacy>

  <testing-strategy>
**Unit Tests (Backend):**
- apps/backend/test/unit/translation.service.spec.ts (Groq API mocks)
- apps/backend/test/unit/groq.service.spec.ts (language mapping, error handling)

**Integration Tests (Backend):**
- apps/backend/test/integration/translation.controller.spec.ts (endpoint, auth, rate limiting)

**Unit Tests (Frontend):**
- src/components/chat/__tests__/translation-display.test.tsx (component behavior)

**E2E Tests:**
- tests/e2e/story-2.5-message-translation.spec.ts (full translation flow, caching, rate limits)
  </testing-strategy>

  <cost-analysis>
**Groq API Costs:**
- Free Tier: 30 RPM, 14,400/day
- Typical translation: ~100 tokens input, ~50 tokens output
- Cost per translation: ~$0.000079 (less than 0.01 cents)

**Monthly Estimate (100 families, 500 translations/day):**
- Database cache hit rate: ~80% (assumption)
- API calls: 100 translations/day (20% of 500)
- Monthly cost: ~$0.24/month

**Infrastructure:**
- Render (NestJS backend): $0/month (free tier)
- Cloudflare Pages (frontend): $0/month (free tier)
- **Total: $0/month** (Groq free tier sufficient for MVP)
  </cost-analysis>

  <deployment-notes>
**Backend (apps/backend/.env):**
```bash
GROQ_API_KEY=gsk_xxx  # Get from https://console.groq.com/keys
CORS_ALLOWED_ORIGINS=http://localhost:3002,https://your-app.pages.dev
```

**IMPORTANT:** Never use NEXT_PUBLIC_GROQ_API_KEY. API key must remain server-side only.

**Deployment Steps:**
1. Backend: Add @nestjs/throttler dependency, create TranslationModule
2. Backend: Run Prisma migration for message_translations table
3. Backend: Deploy to Render (triggers auto-deploy on git push)
4. Frontend: Add TranslationDisplay component, update MessageBubble
5. Frontend: Deploy to Cloudflare Pages (static export)
6. Test: Verify CORS from Cloudflare Pages to Render backend
  </deployment-notes>

  <references>
    <doc path="docs/stories/story-2.5.md">Primary story document (v3.0 - NestJS backend)</doc>
    <doc path="apps/backend/src/main.ts">Existing CORS and validation setup</doc>
    <doc path="docs/solution-architecture.md">Architecture constraints</doc>
    <doc path="docs/stories/story-5.4.md">Language Settings dependency</doc>
    <external url="https://console.groq.com/docs/models">Groq API Documentation</external>
    <external url="https://docs.nestjs.com/security/rate-limiting">NestJS Throttler Docs</external>
    <external url="https://github.com/nestjs/throttler">@nestjs/throttler GitHub</external>
  </references>

  <changelog>
    <version>1.0 (2025-11-01)</version>
    <changes>
      - Initial: Client-direct Groq API calls, in-memory cache
    </changes>
    <version>2.0 (2025-11-02)</version>
    <changes>
      - Changed: Next.js API route proxy, @upstash/ratelimit, 5-layer rate limiting
    </changes>
    <version>3.0 (2025-11-02) - BREAKING CHANGE</version>
    <changes>
      - BREAKING: NestJS backend REST endpoint (vs Next.js API routes)
      - Reason: Static export frontend has no API routes support
      - Simplified: @nestjs/throttler (vs Upstash), 2-tier (vs 5-layer)
      - Benefits: Centralized backend, professional architecture, $0/month
    </changes>
  </changelog>
</story-context>
